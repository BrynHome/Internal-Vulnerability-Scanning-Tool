import os
import re
import pickle

import pandas
import glob

import core.Handler.report_gen as report_gen
import core.Scanning.Network.Network as netExplore
from core.Scanning.Core.Database import Database
from core.Scanning.Network.serviceDiscov import check_port_params
from core.Scanning.Core.Device import Device, port_text
import importlib
import core.Scanning.Vulnerability.xss_detection


def check_comma_ports(ports):
    if not ports:
        return True, "No ports specified"
    t = re.split(',', ports)
    dupe_check = []
    for v in t:
        if not v.isdigit():
            return False, "Value included is not a digit"
        iv = int(v)
        if iv < 1 or iv > 65535:
            return False, "Port not in legal range"
        if iv in dupe_check:
            return False, "Duplicate Value"
        else:
            dupe_check.append(iv)
    return True, "Values Okay!"


def get_pickle(path):
    try:
        file = open(path, 'rb')
        data = pickle.load(file)
        file.close()
        print(path + " data loaded")
        return data
    except FileNotFoundError as e:
        print(path + " File not found.")
        return False
    except pickle.UnpicklingError as e:
        print(path + " Invalid pickle file. Data not loaded")
        return False
    except (IOError, AttributeError, EOFError, ImportError, IndexError) as e:
        print(path + ": " + str(e) + " Data not loaded")
        return False


def get_db(path):
    db = []
    try:
        reader = pandas.read_csv(path, encoding="latin1", header=None, sep=None, engine='python')
        reader = reader.dropna(subset=[0, 1])
        reader = reader.fillna("No Data")
        return reader
    except pandas.errors.ParserError as e:
        print("Malformed csv detected. Recommended action to load and re-save file.")
        return False
    except FileNotFoundError as e:
        print("File not found...")
        return False


def ip_menu(ips, top):
    txt = "\033[1;36mSelect Device to Display:\n\033[1;37m"
    for x in range(top):
        txt = txt + str(x) + ":" + ips[x] + "\n"
    txt = txt + str(top) + ":Return\n"
    return txt


def serv_select_menu(services):
    txt = ""
    l = len(services)
    for x in range(l):
        txt = txt + str(x) + ":" + str(services[x].port) + "\n"
    txt = txt + str(l) + ":Return\n"
    while True:
        choice = input(txt)
        if not choice.isdigit():
            print("Improper input")
        else:
            choice = int(choice)
            if choice < 0 or choice > l:
                print("Improper Input")
            elif choice == l:
                print("Returning...")
                return False
            else:
                return services[choice]


def vuln_script_args_parse(d, s, run_dets):
    def arbitrary_in(arb):
        return input("Enter " + arb + " as an argument for running this script. "
                    "(WARNING: As this is an flexible argument, this value has no validity checking)")
    args = []
    for arg in run_dets["args"]:
        if arg == "ip":
            args.append(d.ip)
        elif arg == "port":
            args.append(s.port)
        elif arg == "mac":
            args.append(d.mac)
        else:
            args.append(arbitrary_in(arg))
    return args


class Driver:
    def __init__(self, subnet):
        self.network = netExplore.NetExplorer(subnet)
        self.db = Database("None", 0)
        self.thresh = 0
        self.auto_check = False

    def main_loop_direct(self):
        menu = main_menu()
        while True:
            choice = input(menu)
            res = self.cmd_parse(choice)
            if not res:
                break

    def cmd_parse(self, command):
        res = True
        if command == "7":
            res = False
            return res
        elif command == "6":
            res = self.data_display_menu()
            return res
        elif command == "5":
            res = self.save_menu()
            return res
        elif command == "4":
            res = self.import_data_menu()
            return res
        elif command == "3":
            res = self.covert_change()
            return res
        elif command == "2":
            res = self.vuln_scan_menu()
            return res
        elif command == "1":
            res = self.net_scan()
            return res
        else:
            print("Improper Input. Enter number from 1-7")
            return "Improper Input. Enter number from 1-7"

    def net_scan(self):
        while True:
            choice = input(
                "\033[1;33mNetwork Scan Options\n\033[1;37m1:Host Discovery\n2:Service Discovery\n3:Return\n")
            if choice == "1":
                res = self.device_discover_menu()
            elif choice == "2":
                res = self.serv_scan()
            elif choice == "3":
                return True
            else:
                print("Improper Input. Enter number from 1-3")

    def device_discover_menu(self):
        while True:
            choice = input("\033[1;39mHost Discovery Options:\n\033[1;37m1: Full Subnet Scan (" + self.network.dd.net +
                           ")\n2: Specific Host\n3: Return\n")
            if choice == "1":
                res = self.network.deviceDiscover()[0]
                print(res)
            elif choice == "2":
                res = self.device_specific_scan_menu()
            elif choice == "3":
                return True, "Returning..."
            else:
                print("Improper Input. Enter number from 1-3")

    def device_specific_scan_menu(self):
        while True:
            choice = input("Enter a IP to scan. (Enter 0 to return)")
            if choice == "0":
                return True
            if re.search("^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.){3}(25[0-5]|(2[0-4]|1\d|[1-9]|)\d)$", choice):
                print(self.network.man_deviceDiscover(choice)[0])
                return True
            else:
                print("Improper input. Must be in ipv4 format.")

    def serv_scan(self):
        def res_check(results):
            if results[1]:
                if self.auto_check:
                    print("Starting Auto Vulnerability Check... (Current DB: " + self.db.name +
                          ", Current Threshold: " + str(self.thresh) + ")\n")
                    self.vuln_scan_existing()
                self.data_display_print_or_report(self.network.getDevices())
            else:
                print(results[0])

        while True:
            auto = "5: Turn On Auto Vulnerability Check (Check for Vulnerabilities after scan)\n"
            if self.auto_check:
                auto = "5: Turn Off Auto Vulnerability Check (Check for Vulnerabilities after scan)\n"
            choice = input("\033[1;39mService Scan Options:\n\033[1;37m1: Full Scan (All devices, UDP & TCP ranges)"
                           "\n2: TCP Scan (All devices, TCP range)\n3: UDP Scan (All devices, UDP range)"
                           "\n4: Manual Scan (User specified devices, UDP or TCP specific)\n" +
                           auto + "6: Return\n")
            if choice == "1":
                tcp = self.port_range_in("TCP")
                udp = self.port_range_in("UDP")
                print("Starting scan...")
                res = self.network.serviceDiscov(tcp, udp)
                res_check(res)
            elif choice == "2":
                tcp = self.port_range_in("TCP")
                print("Starting scan...")
                res = self.network.tcpServiceDiscov(tcp)
                res_check(res)
            elif choice == "3":
                udp = self.port_range_in("UDP")
                print("Starting scan...")
                res = self.network.updServiceDiscov(udp)
                res_check(res)
            elif choice == "4":
                inputs = self.man_scan_in()
                if inputs:
                    print("Starting scan...")
                    res = self.network.manServiceScan(inputs[0], inputs[1], inputs[2])
                    res_check(res)
            elif choice == "5":
                if self.auto_check:
                    self.auto_check = False
                    print("Vulnerability Auto Check Disabled")
                else:
                    self.auto_check = True
                    print("Vulnerability Auto Check Enabled")
            elif choice == "6":
                return "Return main menu"
            else:
                print("Improper Input. Enter number from 1-5")

    def man_scan_in(self):
        res = self.device_select_menu()
        if not res:
            return False
        device = res[0]
        tcp = self.man_scan_in_assist("TCP")
        udp = self.man_scan_in_assist("UDP")
        return [device, tcp, udp]

    def man_scan_in_assist(self, opt):
        while True:
            res = input("Enter " + opt + " ports to scan. (FORMAT OF COMMA SEPERATED VALUES ex. 1,2,3...):\n")
            res = str.strip(res)
            checked = check_comma_ports(res)
            if checked[0]:
                return res
            else:
                print("Improper input. " + str(checked[1]))

    def port_range_in(self, opt):
        while True:
            res = input("Enter range for " + opt + " ports (FORMAT OF lowerbound#-upperbound#):")
            if check_port_params(res):
                return res
            else:
                print("Improper port range. Example of a proper input is 1-1024")

    def vuln_scan_menu(self):
        def thresh_translate(n):
            if n == 0:
                return "Best Matches Only (Least False Positive, Most False Negatives)"
            elif n == 1:
                return "First and Second Best Matches (More False Positives, Less False Negatives)"
            elif n == 2:
                return "First, Second, and Third Best Matches (Most False Positives, Least False Negatives)"

        while True:
            thresh = thresh_translate(self.thresh)
            print("\033[1;31mCurrent DB in use: " + self.db.name +
                  "\nCurrent threshold for vulnerability matching: " + thresh +
                  "\n\033[1;33mVulnerability Scan Options:\n"
                  "\033[1;37m1: Import Vulnerability Database (Replace existing)\n"
                  "2: Recheck current data (Checks existing network data)\n"
                  "3: Change vulnerability matching threshold\n"
                  "4: Vulnerability Detection Scripts\n"
                  "5: Return\n")
            choice = input("Select Option:")
            if choice == "1":
                self.import_db_menu()
            elif choice == "2":
                self.vuln_scan_existing()
            elif choice == "3":
                self.change_thresh_menu(thresh)
            elif choice == "4":
                self.vuln_scripts_menu()
            elif choice == "5":
                return True
            else:
                print("Improper Input")

    def vuln_scripts_menu(self):
        path = "core/Scanning/Vulnerability"
        if len(self.network.getDevices()) == 0:
            print("No Devices available to scan... Returning...")
            return True
        print("\033[1;31mNote: Scripts MUST be python based scripts and have the following return format\n"
              "[vulnerable_status(Boolean), Vulnerability details(List of all details)]\n"
              "The script should also include a variable called service to determine if it is ")
        if not os.path.isdir(path):
            os.mkdir(path)
        scripts = glob.glob1(path, "*.py")
        # Filter for specific data type here
        r = len(scripts)
        if r == 0:
            return "No scripts found"
        opt = "0: Return\n"
        for x in range(r):
            # add option to return
            opt = opt + str(x + 1) + ": " + scripts[x] + "\n"
        print("\033[1;33mScripts Available to Run:\n"
              + opt)
        while True:
            while True:
                res = input("\033[1;37mSelect the script to run: ")
                if not res.isdigit():
                    print("Improper Input")
                elif int(res) in range(1, r + 1):
                    act_res = scripts[int(res) - 1].rsplit(".")[0]
                    path = "core.Scanning.Vulnerability." + act_res
                    self.vuln_script_run(path)
                    return True
                elif res == "0":
                    return True
                else:
                    print("Improper Input")

    def vuln_script_run(self, file):

        try:
            script = importlib.import_module(file)
            run_dets = script.RUN_DETAILS
            print("\033[1;31m" + run_dets["title"])
            print("\033[1;31m" + run_dets["description"])
            print("\033[1;31mScript Arguments: " + ",".join(run_dets["args"]))
        except ModuleNotFoundError as e:
            print("Error retrieving script...")
            return False
        if run_dets["services"][0] == "tcp":
            d = self.device_select_menu()
            if d:
                tcp = d[0].tcp_services
                if not tcp:
                    print("Device has no valid services to scan... Returning")
                    return False
                serv = serv_select_menu(tcp)
            else:
                return True
        elif run_dets["services"][0] == "udp":
            d = self.device_select_menu()
            if d:
                udp = d[0].udp_services
                if not udp:
                    print("Device has no valid services to scan... Returning")
                    return False
                serv = serv_select_menu(udp)
            else:
                return True
        else:
            print("Improper Run Details present.... Adjust to run this script")
            return False

        args = vuln_script_args_parse(d[0], serv, run_dets)

        print("Attempting to run script...")
        try:
            res = script.run(args)
        except:
            print("Error running script...")
            return False
        if res[0]:
            try:
                print("Vulnerability potentially detected... " + res[1])
                serv.vulnerabilities.append({
                "id": file,
                "data": res[1],
                "extra": "",
                "service": "",
                "num_matches": 0,
                "version_matches": ""
                })
                return True
            except TypeError as e:
                print("Error adding vulnerability data... ")
                return False
        else:
            print("Script Detected No Vulnerabilities")
            return True




    def change_thresh_menu(self, thresh):
        while True:
            print("\033[1;31mCurrent threshold for vulnerability matching: " + thresh +
                  "\n\033[1;33mVulnerability Match Threshold Options:\n"
                  "\033[1;37m0: Best Matches Only (Least False Positive, Most False Negatives)\n"
                  "1: First and Second Best Matches (More False Positives, Less False Negatives)\n"
                  "2: First, Second, and Third Best Matches (Most False Positives, Least False Negatives)\n"
                  "3: Return\n")
            choice = input("Select Option:")
            if choice == '0':
                self.thresh = 0
                return
            elif choice == '1':
                self.thresh = 1
                return
            elif choice == '2':
                self.thresh = 2
                return
            elif choice == "3":
                return
            else:
                print("Improper input")

    def import_db_menu(self):
        path = "databases"
        print("Note: Database MUST be of file type csv and have the following format\n"
              "ID | DESCRIPTION | EXTRA(OPTIONAL)\n")
        if not os.path.isdir(path):
            print("Database directory not found... Creating directory.")
            os.mkdir("databases")
            print("Database directory created.")
        databases = glob.glob1(path, "*.csv")
        # Filter for specific data type here
        r = len(databases)
        if r == 0:
            return "No databases found"
        opt = "0: Return\n"
        for x in range(r):
            # add option to return
            opt = opt + str(x + 1) + ": " + databases[x] + "\n"
        print("\033[1;33mDatabases available to import (importing databases will overwrite existing database):\n"
              + opt)
        while True:
            res = input("\033[1;37mSelect the data to import: ")
            if not res.isdigit():
                print("Improper Input")
            elif int(res) in range(1, r + 1):
                act_res = databases[int(res) - 1]
                path = path + "/" + act_res
                directory = get_db(path)
                if type(directory) == bool:
                    return True
                db = Database(act_res, directory.ndim)
                db.populate_db_raw_data(directory)
                self.db = db
                print("Database " + act_res + " with " + str(len(directory)) + " added.")
                return True
            elif res == "0":
                return True
            else:
                print("Improper Input")

    def vuln_scan_existing(self):
        if not self.db.records:
            print("No database found. Please import first.")
            return True
        elif not self.network.getDevices():
            print("No network data found. Import data or perform network scan.")
            return True
        else:
            for device in self.network.getDevices():
                for tcp_service in device.tcp_services:
                    tcp_service.find_vulnerability(self.db, self.thresh)

    def covert_change(self):
        while True:
            print("\033[1;31mCurrent Intensity Value: " + str(self.network.covert_lvl))
            choice = input(
                "\033[1;33mEnter in new scan intensity value 0-5. "
                "This value effects the intensity of device discovery and Service Scan."
                "\n\033[1;37m0=Very Sneaky(VERY SLOW. ONLY USE WHEN CONCERNED ABOUT COVERTNESS)"
                "\n1=Sneaky(SLOW. ONLY USE WHEN CONCERNED ABOUT COVERTNESS)"
                "\n2=Cautious(SLOW. WHEN CAUTIOUS ABOUT BANDWIDTH OR CRASHES"
                "\n3=Normal(STANDARD. SAFEST CHOICE FOR BALANCE BANDWIDTH AND CRASHES)"
                "\n4=Aggressive(FAST. RECOMMENDED OPTION FOR ANY MODERN NETWORK, CAN CAUSE ISSUES, BUT RARE)"
                "\n5=Full Intensity(VERY FAST. GOOD ON FAST NETWORKS. LESS ACCURATE)"
                "\n6=Return\n")
            if choice == "6":
                return True
            res = self.network.covert_change(choice)
            if res:
                print("Level Changed")
                return True
            else:
                print("Improper Input")


    def import_data_menu(self):
        path = "data"
        if not os.path.isdir("data") or len(os.listdir("data")) == 0:
            print("Data directory not found... Creating directory.")
            os.mkdir("data")
            print("Data directory created.")
        data = []
        for it in os.scandir(path):
            if it.is_dir():
                data.append(it.path)
        # Filter for specific data type here
        r = len(data)
        if r == 0:
            return "No data in data directory found"
        opt = "0: Return\n"
        for x in range(r):
            # add option to return
            opt = opt + str(x + 1) + ": " + data[x] + "\n"
        print("\033[1;33mData available to import (importing data will overwrite existing data):\n\033[1;37m" + opt)
        while True:
            res = input("Select the data to import: ")
            if not res.isdigit():
                print("Improper Input")
            elif int(res) in range(1, r + 1):
                path = data[int(res) - 1]
                try:
                    directory = os.listdir(path)
                except FileNotFoundError as e:
                    print("Directory not found... aborting")
                    return True
                if len(directory) == 0:
                    print("No Data found")
                else:
                    tmp_d = []
                    for d in directory:
                        data = get_pickle(path + "/" + d)
                        if data:
                            tmp_d.append(data)
                    if tmp_d:
                        self.network.devices = tmp_d
                        print("Data successfully imported.")
                        return True
                    else:
                        print("Error importing data...")
                        return True
            elif res == "0":
                return True
            else:
                print("Improper Input")

    def save_menu(self):
        if not os.path.isdir("data"):
            print("Data directory not found... Creating directory.")
            os.mkdir("data")
            print("Data directory created.")
        if len(self.network.getDevices()) <= 0:
            print("No data to be saved. Returning...")
            return True
        while True:
            choice = input("Enter name for saved data (Leave blank to return):\n")
            if choice == "":
                return True
            choice = "data/" + choice
            if os.path.isdir(choice):
                res = input("This directory already exists. Overwrite data?"
                            "\n1: Yes\n2: No\n")
                if res == '1':
                    self.save(choice)
                    return True
                else:
                    continue
            else:
                os.mkdir(choice)
                self.save(choice)
                return True

    def save(self, choice):
        devices = self.network.getDevices()
        for device in devices:
            file = open((choice + '/' + device.ip + '.obj'), 'wb')
            pickle.dump(device, file)
            file.close()
        print("Data Saved!")

    def data_display_menu(self):
        while True:
            choice = input("\033[1;33mData Display/Report Options:\n"
                           "\033[1;37m1:All devices"
                           "\n2:Select Device\n3:Return\n")
            if choice == "1":
                devices = self.network.getDevices()
                if devices:
                    self.data_display_print_or_report(devices)
                else:
                    print("No device data detected to display or report...")
            elif choice == "2":
                out = self.device_select_menu()
                if out:
                    self.data_display_print_or_report([out[0]])
            elif choice == "3":
                return True
            else:
                print("Improper Input")

    def data_display_print_or_report(self, devices: [Device]):
        while True:
            choice = input("\033[1;35mDisplay Information or Generate Report?:\n\033[1;37m1:Display"
                           "\n2:Report\n3:Return\n")
            if choice == "1":
                if len(devices) > 1:
                    print(self.network.text_detailed())
                elif len(devices) == 1:
                    print(devices[0].detail_text())
                else:
                    print("Unable to display information.")
                return True
            elif choice == "2":
                self.data_display_report(devices)
                return True
            elif choice == "3":
                return True
            else:
                print("Improper Input")

    def device_select_menu(self):
        ips = self.network.ips()
        devices = self.network.getDevices()
        if not devices:
            print("No devices detected to display or print...")
            return None
        top = len(ips)
        txt = ip_menu(ips, top)
        while True:
            choice = input(txt)
            if not choice.isdigit():
                print("Improper input")
            else:
                choice = int(choice)
                if choice < 0 or choice > top:
                    print("Improper Input")
                elif choice == top:
                    print("Returning...")
                    return None
                else:
                    return [devices[choice], True]

    def data_display_report(self, devices):
        res = report_gen.report_gen(devices)
        if res:
            print("Report(s) created successfully. (Created at path " + res + ")")


def start(mode, subnet):
    drive = Driver(subnet)
    drive.main_loop_direct()
    return 1


def main_menu():
    menu = ("\033[1;34mMain Menu:\n\033[1;37m1: Network Scan\n2: Vulnerability Scan"
            "\n3: Set Scan Intensity\n4: Import Data\n5: Save Data\n6: Display/Report Data\n7: Exit\n")
    return menu
