import os
import re
import pickle
import pandas
import glob

import core.Handler.report_gen as report_gen
import core.Handler.receiver as recv
import core.Scanning.Network.NetExplorer as netExplore
from core.Scanning.Core.Database import Database
from core.Scanning.Network.serviceDiscov import check_port_params
from core.Scanning.Core.Device import Device

# TO DO
"""
ADD CHECKS TO ANY INPUT AREAS TO DETERMINE IF IN DIRECT OR REMOTE MODE. IF REMOTE, DO SEND/RECV_COMMAND INSTEAD
SEPARATE DIRECT DRIVER AND REMOTE DRIVER
"""


def check_comma_ports(ports):
    if not re.search(',', ports):
        return False
    t = re.split(',', ports)
    for v in t:
        if not v.isdigit():
            return False
        iv = int(v)
        if not iv > 0 or not iv < 65535:
            return False


def get_pickle(path):
    try:
        file = open(path, 'rb')
        data = pickle.load(file)
        file.close()
        print(path + " data loaded")
        return data
    except FileNotFoundError as e:
        print(path + " File not found.")
        return False
    except pickle.UnpicklingError as e:
        print(path + " Invalid pickle file. Data not loaded")
        return False
    except (IOError, AttributeError, EOFError, ImportError, IndexError) as e:
        print(path + ": " + str(e) + " Data not loaded")
        return False


def get_db(path):
    db = []
    try:
        reader = pandas.read_csv(path, encoding="latin1", header=None, sep=None, engine='python')
        return reader
    except pandas.errors.ParserError as e:
        print("Malformed csv detected. Recommended action to load and re-save file.")
        return False
    except FileNotFoundError as e:
        print("File not found...")
        return False


def ip_menu(ips, top):
    txt = "\033[1;36mSelect Device to Display:\n\033[1;37m"
    for x in range(top):
        txt = txt + str(x) + ":" + ips[x] + "\n"
    txt = txt + str(top) + ":Return\n"
    return txt


class Driver:
    def __init__(self, subnet):
        self.network = netExplore.NetExplorer(subnet)
        self.direct_control = True
        self.remote = None
        self.db = Database("None", 0)
        self.thresh = 0
        self.auto_check = False

    def main_loop_direct(self):
        self.direct_control = True
        menu = main_menu()
        while True:
            choice = input(menu)
            res = self.cmd_parse(choice)
            if not res:
                break

    def main_loop_remote(self, remote):
        self.direct_control = False
        self.remote = remote
        self.remote.connect()
        while True:
            cmd = self.remote.recv_command()
            res = self.cmd_parse(cmd)
            if not res:
                break
        self.remote.disconnect()

    def cmd_parse(self, command):
        res = True
        if command == "7":
            res = False
            return res
        elif command == "6":
            res = self.data_display_menu()
            return res
        elif command == "5":
            res = self.save_menu()
            return res
        elif command == "4":
            res = self.import_data_menu()
            return res
        elif command == "3":
            res = self.covert_change()
            return res
        elif command == "2":
            res = self.vuln_scan_menu()
            return res
        elif command == "1":
            res = self.net_scan()
            return res
        else:
            print("Improper Input. Enter number from 1-7")
            return "Improper Input. Enter number from 1-7"

    def net_scan(self):
        while True:
            choice = input(
                "\033[1;33mNetwork Scan Options\n\033[1;37m1:Device Discovery\n2:Service Discovery\n3:Return\n")
            if choice == "1":
                res = self.device_discover_menu()
            elif choice == "2":
                res = self.serv_scan()
            elif choice == "3":
                return True
            else:
                print("Improper Input. Enter number from 1-3")

    def device_discover_menu(self):
        while True:
            choice = input("\033[1;39mDevice Scan Options:\n\033[1;37m1: Full Subnet Scan (" + self.network.dd.net +
                           ")\n2: Specific Host\n3: Return\n")
            if choice == "1":
                res = self.network.deviceDiscover()[0]
                print(res)
            elif choice == "2":
                res = self.device_specific_scan_menu()
            elif choice == "3":
                return True, "Returning..."
            else:
                print("Improper Input. Enter number from 1-3")

    def device_specific_scan_menu(self):
        while True:
            choice = input("Enter a IP to scan. (Enter 0 to return)")
            if choice == "0":
                return True
            if re.search("^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.){3}(25[0-5]|(2[0-4]|1\d|[1-9]|)\d)$", choice):
                print(self.network.man_deviceDiscover(choice)[0])
                return True
            else:
                print("Improper input. Must be in ipv4 format.")

    def serv_scan(self):
        def res_check(results):
            if results[1]:
                if self.auto_check:
                    print("Starting Auto Vulnerability Check... (Current DB: " + self.db.name +
                          ", Current Threshold: " + str(self.thresh) + ")\n")
                    self.vuln_scan_existing()
                self.data_display_print_or_report(self.network.getDevices())
            else:
                print(results[0])
        if self.direct_control:
            while True:
                auto = "6: Turn On Auto Vulnerability Check (Check for Vulnerabilities after scan)\n"
                if self.auto_check:
                    auto = "6: Turn Off Auto Vulnerability Check (Check for Vulnerabilities after scan)\n"
                choice = input("\033[1;39mService Scan Options:\n\033[1;37m1: Full Scan (All devices, UDP & TCP ranges)"
                               "\n2: TCP Scan (All devices, TCP range)\n3: UDP Scan (All devices, UDP range)"
                               "\n4: Manual Scan (User specified devices, UDP or TCP specific)\n" +
                               auto + "5: Return\n")
                if choice == "1":
                    tcp = self.port_range_in("TCP")
                    udp = self.port_range_in("UDP")
                    print("Starting scan...")
                    res = self.network.serviceDiscov(tcp, udp)
                    res_check(res)
                elif choice == "2":
                    tcp = self.port_range_in("TCP")
                    print("Starting scan...")
                    res = self.network.tcpServiceDiscov(tcp)
                    res_check(res)
                elif choice == "3":
                    udp = self.port_range_in("UDP")
                    print("Starting scan...")
                    res = self.network.updServiceDiscov(udp)
                    res_check(res)
                elif choice == "4":
                    inputs = self.man_scan_in()
                    if inputs:
                        print("Starting scan...")
                        res = self.network.manServiceScan(inputs[0], inputs[1], inputs[2])
                        res_check(res)
                elif choice == "5":
                    if self.auto_check:
                        self.auto_check = False
                        print("Vulnerability Auto Check Disabled")
                    else:
                        self.auto_check = True
                        print("Vulnerability Auto Check Enabled")
                elif choice == "6":
                    return "Return main menu"
                else:
                    print("Improper Input. Enter number from 1-5")
        else:
            print()

    def man_scan_in(self):
        res = self.device_select_menu()
        if not res:
            return False
        device = res[0]
        tcp = self.man_scan_in_assist("TCP")
        udp = self.man_scan_in_assist("UDP")
        return [device, tcp, udp]

    def man_scan_in_assist(self, opt):
        if self.direct_control:
            res = input("Enter " + opt + " ports to scan. (FORMAT OF COMMA SEPERATED VALUES ex. 1,2,3...):\n")
            res = str.strip(res)
            return res

    def port_range_in(self, opt):
        if self.direct_control:
            while True:
                res = input("Enter range for " + opt + " ports (FORMAT OF lowerbound#-upperbound#):")
                if check_port_params(res):
                    return res
                else:
                    print("Improper port range. Example of a proper input is 1-1024")
        else:
            while True:
                self.remote.send_response("Enter range for " + opt +
                                          " (MUST BE IN FORMAT OF lowerbound#-upperbound#):", True)
                res = self.remote.recv_command()
                if check_port_params(res):
                    return res
                else:
                    self.remote.send_response("Improper port range. Example of a proper input is 1-1024", False)

    def vuln_scan_menu(self):
        def thresh_translate(n):
            if n == 0:
                return "Best Matches Only (Least False Positive, Most False Negatives)"
            elif n == 1:
                return "First and Second Best Matches (More False Positives, Less False Negatives)"
            elif n == 2:
                return "First, Second, and Third Best Matches (Most False Positives, Least False Negatives)"

        while True:
            thresh = thresh_translate(self.thresh)
            print("\033[1;31mCurrent DB in use: " + self.db.name +
                  "\nCurrent threshold for vulnerability matching: " + thresh +
                  "\n\033[1;33mVulnerability Scan Options:\n"
                  "\033[1;37m1: Import Vulnerability Database (Replace existing)\n"
                  "2: Recheck current data (Checks existing network data)\n"
                  "3: Change vulnerability matching threshold\n"
                  "4: Return\n")
            choice = input("Select Option:")
            if choice == "1":
                self.import_db_menu()
            elif choice == "2":
                self.vuln_scan_existing()
            elif choice == "3":
                self.change_thresh_menu(thresh)
            elif choice == "4":
                return True
            else:
                print("Improper Input")

    def change_thresh_menu(self, thresh):
        while True:
            print("\033[1;31mCurrent threshold for vulnerability matching: " + thresh +
                  "\n\033[1;33mVulnerability Match Threshold Options:\n"
                  "\033[1;37m0: Best Matches Only (Least False Positive, Most False Negatives)\n"
                  "1: First and Second Best Matches (More False Positives, Less False Negatives)\n"
                  "2: First, Second, and Third Best Matches (Most False Positives, Least False Negatives)\n"
                  "3: Return\n")
            choice = input("Select Option:")
            if choice == '0':
                self.thresh = 0
                return
            elif choice == '1':
                self.thresh = 1
                return
            elif choice == '2':
                self.thresh = 2
                return
            elif choice == "3":
                return
            else:
                print("Improper input")

    def import_db_menu(self):
        path = "databases"
        print("Note: Database MUST be of file type csv and have the following format\n"
              "ID | DESCRIPTION | EXTRA(OPTIONAL)\n")
        if not os.path.isdir(path):
            print("Database directory not found... Creating directory.")
            os.mkdir("databases")
            print("Database directory created.")
        databases = glob.glob1(path, "*.csv")
        # Filter for specific data type here
        r = len(databases)
        if r == 0:
            return "No databases found"
        if self.direct_control:

            opt = "0: Return\n"
            for x in range(r):
                # add option to return
                opt = opt + str(x + 1) + ": " + databases[x] + "\n"
            print("\033[1;33mDatabases available to import (importing databases will overwrite existing database):\n"
                  + opt)
            while True:
                res = input("\033[1;37mSelect the data to import: ")
                if not res.isdigit():
                    print("Improper Input")
                elif int(res) in range(1, r + 1):
                    act_res = databases[int(res) - 1]
                    path = path + "/" + act_res
                    directory = get_db(path)
                    db = Database(act_res, directory.ndim)
                    db.populate_db_raw_data(directory)
                    self.db = db
                    print("Database " + act_res + " with " + str(len(directory)) + " added.")
                    return True
                elif res == "0":
                    return True
                else:
                    print("Improper Input")
        return

    def vuln_scan_existing(self):
        if not self.db.records:
            print("No database found. Please import first.")
            return True
        elif not self.network.getDevices():
            print("No network data found. Import data or perform network scan.")
            return True
        else:
            for device in self.network.getDevices():
                for tcp_service in device.tcp_services:
                    tcp_service.find_vulnerability(self.db, self.thresh)

    def covert_change(self):
        while True:
            choice = input(
                "Enter in new covert value 0-4. This value effects the intensity of the network scan."
                "\n0=Lowest Level of Covertness\n4=Highest Level of Covertness\n")
            res = self.network.covert_change(choice)
            if res:
                return "Level changed"

    def import_data_menu(self):
        path = "data"
        if not os.path.isdir("data") or len(os.listdir("data")) == 0:
            print("Data directory not found... Creating directory.")
            os.mkdir("data")
            print("Data directory created.")
        data = []
        for it in os.scandir(path):
            if it.is_dir():
                data.append(it.path)
        # Filter for specific data type here
        r = len(data)
        if r == 0:
            return "No data in data directory found"
        if self.direct_control:
            opt = "0: Return\n"
            for x in range(r):
                # add option to return
                opt = opt + str(x + 1) + ": " + data[x] + "\n"
            print("\033[1;33mData available to import (importing data will overwrite existing data):\n\033[1;37m" + opt)
            while True:
                res = input("Select the data to import: ")
                if not res.isdigit():
                    print("Improper Input")
                elif int(res) in range(1, r + 1):
                    path = data[int(res) - 1]
                    directory = os.listdir(path)
                    if len(directory) == 0:
                        print("No Data found")
                    else:
                        for d in directory:
                            data = get_pickle(path + "/" + d)
                            self.network.addDevice(data)
                        print("Data successfully imported.")
                        return True
                elif res == "0":
                    return True
                else:
                    print("Improper Input")
        else:
            self.remote.send_response("Data available to import (importing data will overwrite existing data):\n"
                                      + data.__str__() + "\nGive Path:", True)

    def save_menu(self):
        if not os.path.isdir("data"):
            print("Data directory not found... Creating directory.")
            os.mkdir("data")
            print("Data directory created.")
        if len(self.network.getDevices()) <= 0:
            print("No data to be saved. Returning...")
            return True
        while True:
            choice = input("Enter name for saved data (Leave blank to return):\n")
            if choice == "":
                return True
            choice = "data/" + choice
            if os.path.isdir(choice):
                res = input("This directory already exists. Overwrite data?"
                            "\n1: Yes\n2: No\n")
                if res == '1':
                    self.save(choice)
                    return True
                else:
                    continue
            else:
                os.mkdir(choice)
                self.save(choice)
                return True

    def save(self, choice):
        devices = self.network.getDevices()
        for device in devices:
            file = open((choice + '/' + device.ip + '.obj'), 'wb')
            pickle.dump(device, file)
            file.close()
        print("Data Saved!")

    def data_display_menu(self):
        while True:
            choice = input("\033[1;33mData Display/Report Options:\n"
                           "\033[1;37m1:All devices"
                           "\n2:Select Device\n3:Return\n")
            if choice == "1":
                self.data_display_print_or_report(self.network.getDevices())
            elif choice == "2":
                out = self.device_select_menu()
                if out:
                    self.data_display_print_or_report([out[0]])
            elif choice == "3":
                return True
            else:
                print("Improper Input")

    def data_display_print_or_report(self, devices: [Device]):
        while True:
            choice = input("\033[1;35mDisplay Information or Generate Report?:\n\033[1;37m1:Display"
                           "\n2:Report\n3:Return\n")
            if choice == "1":
                if len(devices) > 1:
                    print(self.network.text_detailed())
                elif len(devices) == 1:
                    print(devices[0].detail_text())
                else:
                    print("Unable to display information.")
                return True
            elif choice == "2":
                self.data_display_report(devices)
                return True
            elif choice == "3":
                return True
            else:
                print("Improper Input")

    def device_select_menu(self):
        ips = self.network.ips()
        devices = self.network.getDevices()
        top = len(ips)
        txt = ip_menu(ips, top)
        while True:
            choice = input(txt)
            if not choice.isdigit():
                print("Improper input")
            else:
                choice = int(choice)
                if choice < 0 or choice > top:
                    print("Improper Input")
                elif choice == top:
                    print("Returning...")
                    return None
                else:
                    return [devices[choice], True]

    def data_display_report(self, devices):
        res = report_gen.report_gen(devices)
        if res:
            print("Report(s) created successfully. (Created at path " + res + ")")


def start(mode, subnet):
    drive = Driver(subnet)
    if mode == "1":
        drive.main_loop_direct()
        return 1
    elif mode == "2":
        remote = recv.Receiver("192.168.0.0")
        drive.main_loop_remote(remote)
        return 1
    else:
        return 0


def main_menu():
    menu = ("\033[1;34mMain Menu:\n\033[1;37m1: Network Scan\n2: Vulnerability Scan"
            "\n3: Set Covert Level\n4: Import Data\n5: Save Data\n6: Display/Report Data\n7: Exit\n")
    return menu
