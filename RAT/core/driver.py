import os
import re

from IPython.display import clear_output
import core.Handler.receiver as recv
import core.Scanning.Network.NetExplorer as netExplore
from core.Scanning.Network.serviceDiscov import check_port_params

# TO DO
"""
ADD CHECKS TO ANY INPUT AREAS TO DETERMINE IF IN DIRECT OR REMOTE MODE. IF REMOTE, DO SEND/RECV_COMMAND INSTEAD
SEPARATE DIRECT DRIVER AND REMOTE DRIVER
"""


def check_comma_ports(ports):
    if not re.search(',', ports):
        return False
    t = re.split(',', ports)
    for v in t:
        if not v.isdigit():
            return False
        iv = int(v)
        if not iv > 0 or not iv < 65535:
            return False


class Driver:
    def __init__(self, subnet):
        self.network = netExplore.NetExplorer(subnet)
        self.direct_control = True
        self.remote = None

    def main_loop_direct(self):
        self.direct_control = True
        while True:
            menu = main_menu()
            choice = input(menu)
            res = self.cmd_parse(choice)
            if not res:
                break


    def main_loop_remote(self, remote):
        self.direct_control = False
        self.remote = remote
        self.remote.connect()
        while True:
            cmd = self.remote.recv_command()
            res = self.cmd_parse(cmd)
            if not res:
                break
        self.remote.disconnect()

    def cmd_parse(self, command):
        res = True
        if command == "7":
            res = False
            return res
        elif command == "6":
            res = self.data_display()
            return res
        elif command == "5":
            res = self.save()
            return res
        elif command == "4":
            res = self.import_data()
            return res
        elif command == "3":
            res = self.covert_change()
            return res
        elif command == "2":
            res = self.vuln_scan()
            return res
        elif command == "1":
            res = self.net_scan()
            return res
        else:
            print("Improper Input. Enter number from 1-7")
            return "Improper Input. Enter number from 1-7"

    def covert_change(self):
        while True:
            choice = input(
                "Enter in new covert value 0-4. This value effects the intensity of the network scan."
                "\n0=Lowest Level of Covertness\n4=Highest Level of Covertness\n")
            res = self.network.covert_change(choice)
            if res:
                return "Level changed"

    def net_scan(self):
        while True:
            choice = input(
                "\033[1;33mNetwork Scan Options\n\033[1;37m1:Device Discovery\n2:Service Discovery\n3:Return\n")
            if choice == "1":
                return self.network.deviceDiscover()
            elif choice == "2":
                return self.serv_scan()
            elif choice == "3":
                return True
            else:
                print("Improper Input. Enter number from 1-3")

    def serv_scan(self):
        if self.direct_control:
            while True:
                choice = input("\033[1;39mService Scan Options:\n\033[1;37m1:Full Scan (All devices, UDP & TCP ranges)"
                               "\n2:TCP Scan (All devices, TCP range)\n3:UDP Scan (All devices, UDP range)"
                               "\n4:Manual Scan (User specified devices, UDP or TCP specific)\n5:Return\n")
                if choice == "1":
                    tcp = self.port_range_in("TCP")
                    udp = self.port_range_in("UDP")
                    return self.network.serviceDiscov(tcp, udp)
                elif choice == "2":
                    tcp = self.port_range_in("TCP")
                    return self.network.tcpServiceDiscov(tcp)
                elif choice == "3":
                    udp = self.port_range_in("UDP")
                    return self.network.updServiceDiscov(udp)
                elif choice == "4":
                    inputs = self.man_scan_in()
                    return self.network.manServiceScan(inputs[0], inputs[1], inputs[2])
                elif choice == "5":
                    return "Return main menu"
                else:
                    print("Improper Input. Enter number from 1-3")
        else:
            print()

    def man_scan_in(self):
        ip = self.man_scan_in_assist("IP")
        tcp = self.man_scan_in_assist("TCP")
        udp = self.man_scan_in_assist("UDP")
        return [ip, tcp, udp]

    def man_scan_in_assist(self, opt):
        if self.direct_control:
            res = input("Enter " + opt + "s to scan. (FORMAT OF COMMA SEPERATED VALUES ex. 1,2,3...):\n")
            res = str.strip(res)
            return res

    def port_range_in(self, opt):
        if self.direct_control:
            while True:
                res = input("Enter range for " + opt + " ports (FORMAT OF lowerbound#-upperbound#):")
                if check_port_params(res):
                    return res
                else:
                    print("Improper port range. Example of a proper input is 1-1024")
        else:
            while True:
                self.remote.send_response("Enter range for " + opt +
                                          " (MUST BE IN FORMAT OF lowerbound#-upperbound#):", True)
                res = self.remote.recv_command()
                if check_port_params(res):
                    return res
                else:
                    self.remote.send_response("Improper port range. Example of a proper input is 1-1024", False)

    def import_data(self):
        if not os.path.isdir("data") or len(os.listdir("data")) == 0:
            print("Data directory not found... Creating directory.")
            os.mkdir("data")
            print("Data directory created.")
        data = os.listdir("data")
        # Filter for specific data type here
        if len(data) == 0:
            return "No data in data directory found"
        if self.direct_control:
            print("Data available to import (importing data will overwrite existing data):\n" + data.__str__())
            res = input("Give path")
        else:
            self.remote.send_response("Data available to import (importing data will overwrite existing data):\n"
                                      + data.__str__() + "\nGive Path:", True)

    def data_display(self):
        while True:
            choice = input("\033[1;35mData Display/Report Options:\n"
                           "\033[1;37m1:All devices, All Details"
                           "\n2:Select Device\n3:Return\n")
            if choice == "1":
                devices = self.network.getDevices()
                self.data_display_print_or_report(devices)
            elif choice == "2":
                self.data_display_device_select()
            elif choice == "3":
                return True
            else:
                print("Improper Input")

    def data_display_print_or_report(self, devices):
        while True:
            choice = input("\033[1;36mDisplay Information or Generate Report?:\n\033[1;37m1:Display"
                           "\n2:Report\n")
            if choice == "1":
                print(self.network.text_detailed())
                return
            elif choice == "2":
                self.data_display_report(devices)
                return
            else:
                print("Improper Input")

    def data_display_device_select(self):
        ips = self.network.ips()
        devices = self.network.getDevices()
        txt = "\033[1;36mSelect Device to Display:\n\033[1;37m"
        top = len(ips)
        for x in range(top):
            txt = txt + str(x) + ":" + ips[x] + "\n"
        txt = txt + str(top) + ":Return\n"
        while True:
            choice = input(txt)
            if not choice.isdigit():
                print("Improper input")
            else:
                choice = int(choice)
                if choice < 0 or choice > top:
                    print("Improper Input")
                elif choice == top:
                    print("Returning...")
                    return "Return", True
                else:
                    device = devices[choice]

    def data_display_report(self, devices):
        return

    def vuln_scan(self):
        return

    def save(self):
        return


def start(mode, subnet):
    drive = Driver(subnet)
    if mode == "1":
        drive.main_loop_direct()
        return 1
    elif mode == "2":
        remote = recv.Receiver("192.168.0.0")
        drive.main_loop_remote(remote)
        return 1
    else:
        return 0


def main_menu():
    clear_output(wait=True)
    menu = ("\033[1;34mMain Menu:\n\033[1;37m1: Network Scan\n2: Vulnerability Scan"
            "\n3: Set Covert Level\n4: Import Data\n5: Save Data\n6: Display/Report Data\n7: Exit\n")
    return menu
