import re
import pandas
from tabulate import tabulate

from core.Scanning.Core.Database import Database


def not_match(l, i):
    if not l:
        return False
    elif l[-1]["id"] == i:
        return False
    else:
        return True


class Service:

    def __init__(self, port, version, name, product, extra, cpe, state):
        self.version = version
        self.port = port
        self.name = name
        self.product = product
        self.extra = extra
        self.cpe = cpe
        self.state = state
        self.vulnerabilities = []

    def text(self):
        res = self.text_no_vuln()
        if self.vulnerabilities:
            res = res + self.vulnerability_display() + "\n"

        return res

    def text_no_vuln(self):
        extra = self.text_extra()
        res = (self.name
               + '\nVersion: ' + self.version
               + '\nPort: ' + str(self.port)
               + '\nProduct: ' + self.product
               + '\nExtra details: ' + extra
               + '\nCPE(Common Platform Enumeration): ' + self.cpe
               + '\nState(As of last scan): ' + self.state
               + '\n')
        return res

    def text_extra(self):
        extra = ''
        if type(self.extra) == list:
            for ex in self.extra:
                if type(ex) == list:
                    for x in ex:
                        extra = extra + x + ' '
                else:
                    extra = extra + ex + ' '
        else:
            extra = self.extra
        return extra

    def vulnerability_data(self):
        df = pandas.DataFrame.from_records(self.vulnerabilities)
        return df

    def vulnerability_display(self):
        df = pandas.DataFrame.from_records(self.vulnerabilities).drop("extra", axis=1).set_index('id')
        tb = tabulate(df, headers='keys', tablefmt='psql')
        return tb

    def find_vulnerability(self, db: Database, threshold):
        def matcher(word_s, word_version, e, e_v, e_d_l):
            tracker = 0
            for word in word_s:
                word_l = word.lower()
                result = e_d_l.find(word_l)
                if result != -1:
                    e["service"] = e["service"] + word + ","
                    e["num_matches"] = e["num_matches"] + 1
                    tracker = tracker + 1
            e["service"].strip(",")
            if word_version and word_version != "" and e_v and tracker > 0:
                e_v = ' '.join(e_v)
                periods = len(re.findall('\.', word_version))
                r = e_v.find(word_version)
                if r != -1:
                    e["version_matches"] = e["version_matches"] + "," + word_version
                    e["num_matches"] = e["num_matches"] + 1
                for i in range(1, periods + 1):
                    split = word_version.rsplit('.', i)[0] + "."
                    r = e_v.find(split)
                    if r != -1:
                        e["version_matches"] = e["version_matches"] + split + "X,"
                        e["num_matches"] = e["num_matches"] + 1
                e["version_matches"].strip(",")

        def match_result(matches_s, thresh):
            best_match = 0
            best_matches = []
            for m in matches_s:
                if m["num_matches"] > best_match:
                    best_match = m["num_matches"]
                    best_matches.clear()
                    best_matches.append(m)
                elif m["num_matches"] == best_match:
                    best_matches.append(m)
            if thresh > 0:  # Threshold for a match being accepted
                if best_match > 3:
                    thresh_count = 0
                    for top in range(best_match - 1, 1, -1):
                        for m in matches:
                            if m["num_matches"] == top:
                                best_matches.append(m)
                        thresh_count = thresh_count + 1
                        if thresh_count == thresh:
                            break
                else:
                    print("Best Match insufficient to run additional passes... ")
            return best_matches, best_match

        # Clean name before maybe?
        words = self.product.split(" ")
        matches = []
        for entry in db.records:
            entry_struct = {
                "id": entry.id,
                "data": entry.data,
                "extra": entry.extra,
                "service": "",
                "num_matches": 0,
                "version_matches": ""
            }
            entry_id = entry.id
            entry_data = entry.data
            entry_extra = entry.extra
            entry_versions = re.findall("\d+(?:\.\d+)+", entry_data)
            entry_status = {"No": "No matches"}
            if entry_data:
                e_data_l = entry_data.lower()
                matcher(words, self.version, entry_struct, entry_versions, e_data_l)
                if type(self.extra) == list:
                    for ex in self.extra:
                        if type(ex) == list:
                            words_n = ex[0].split(" ")
                            matcher(words_n, ex[1], entry_struct, entry_versions, e_data_l)
                if entry_struct['num_matches'] > 0:
                    matches.append(entry_struct)
        if matches:
            sorted_matches = sorted(matches, key=lambda x: x["num_matches"], reverse=True)
            res = match_result(sorted_matches, threshold)
            if res[1] > 1:
                self.vulnerabilities = res[0]
                print("Best match: " + str(res[1]))
            else:
                print("No Reasonable matches found. (Must have a best match of at least 2)")
